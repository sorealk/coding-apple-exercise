<div></div>

<script>

// 변수의 특징 : 선언, 할당, 범위

// var 재선언O, 재할당O, 범위=function
// let 재선언X, 재할당O, 범위={ }
// const 재선언X, 재할당X,범위={ }

const 사람 = { 이름 : 'kim'}
사람.이름 = 'Park' // 에러 안남. 오브젝트 내부 값 변경 가능. 변수 자체를 재할당하는게 아니기때문.

Object.freeze(사람) // => 값을 절대 바꿀 수 없게 됨


// 변수의 Hoisting 현상

// 우리의 코드
// var 나이 = 30
// 자바스크립트의 해석 (상단에서 선언하는 호이스팅 현상)
// -> var 나이;
// -> 나이 = 30;


// 전역변수 : 모든 곳에서 쓸 수 있는 변수 <-> 지역변수
// 1. script 제일 바깥에 만들기
// 2.(권장) window로 전역변수 만들기 가능. window.이름 = 김
// window = 자바스크립트 기본 함수를 담은 {오브젝트}

// 함수선언도 Hoisting

// 근데 선언만 호이스팅이고 할당은 호이스팅 아님
// function 함수 (); 
// var 함수 = funtion(){}은 다름.

// 나랑 최대한 가까이 있는 변수를 사용하게 됨.


// tagged literal
// 해체 분석기 파라미터1. ${} 양옆 문자들을 Array화 해줌
// 해체 분석기 파라미터2. ${변수}를 뜻함
var 변수 = '김연아';
var 문자 = `안녕하세요 ${변수}입니다`;

function 해체분석기(문자들, 변수들) {
    console.log(문자들);
    console.log(변수들);
}

// 예제 1
var pants = 0;
var socks =100;
`바지${pants} 양말${socks}`

function 해체분석기2(문자들, 변수1, 변수2) { //...변수들 spread operater 가능
    console.log(문자들[1]+변수1+문자들[0]+변수2);
}

function 해체분석기3(문자들, ...변수들) {
    if(변수들[0] == 0) {
        console.log(문자들[0]+'안팔아요'+문자들[1]+' '+변수들[1]);
    }
}


// spread operator 쓸곳 3. 함수 파라미터 넣을 때
// Spread Operator : apply, call 함수

function 더하기(a,b,c) {
    console.log(a + b + c)
}

var 어레이 = [10, 20, 30];

더하기(어레이[0], 어레이[1], 어레이[2]) // 주먹구구 방식
더하기.apply(undefined, 어레이); // 옛방식
더하기(...어레이); //요즘 방식


// *apply, call 함수

// apply 함수
// person.인사()를 person2에 적용하고 싶을때 
// call 함수 : apply 비슷함. apply는 파라미터를 array 형태로 집어넣기 가능

var person = {
    인사 : function() {
        console.log(this.name + '안녕')
    }
}

var person2 = {
    name : 'kim'
}

person.인사();
person.인사.apply(person2) // -> person.인사()를 person2에 적용하고 싶을 때
person.인사.call(person2) 

person.인사.apply(person2, [1,2]); // // 파라미터 집어넣고 싶을 때 array로
person.인사.call(person2, 1,2);   // 파라미터 집어넣고 싶을 때 그냥 //1,2는 그냥 파라미터 예시




</script>


